using System.IO;
using System.Text.Json;
using System.Text.Json.Nodes;

namespace ClaudeUsageWin.Services;

public static class StatuslineService
{
    private static readonly string ClaudeDir = Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".claude");
    private static readonly string ScriptPath = Path.Combine(ClaudeDir, "claude-usage-statusline.ps1");
    private static readonly string SettingsPath = Path.Combine(ClaudeDir, "settings.json");

    public static bool IsInstalled => File.Exists(ScriptPath);

    public static void Install()
    {
        Directory.CreateDirectory(ClaudeDir);
        File.WriteAllText(ScriptPath, GetScriptContent());
        AddSettingsHook();
        Logger.Log("Statusline: installed to " + ScriptPath);
    }

    public static void Uninstall()
    {
        if (File.Exists(ScriptPath)) File.Delete(ScriptPath);
        RemoveSettingsHook();
        Logger.Log("Statusline: uninstalled");
    }

    private static void AddSettingsHook()
    {
        try
        {
            JsonNode? root = null;
            if (File.Exists(SettingsPath))
            {
                var existing = File.ReadAllText(SettingsPath);
                if (!string.IsNullOrWhiteSpace(existing))
                    root = JsonNode.Parse(existing);
            }
            root ??= new JsonObject();

            var escapedPath = ScriptPath.Replace("\\", "\\\\");
            var command = $"powershell -NoProfile -ExecutionPolicy Bypass -File \"{escapedPath}\"";

            root["statusLine"] = new JsonObject
            {
                ["type"] = "command",
                ["command"] = command,
                ["padding"] = 0
            };

            var options = new JsonSerializerOptions { WriteIndented = true };
            File.WriteAllText(SettingsPath, root.ToJsonString(options));
        }
        catch (Exception ex)
        {
            Logger.Log("Statusline: failed to update settings.json - " + ex.Message);
        }
    }

    private static void RemoveSettingsHook()
    {
        try
        {
            if (!File.Exists(SettingsPath)) return;
            var existing = File.ReadAllText(SettingsPath);
            if (string.IsNullOrWhiteSpace(existing)) return;

            var root = JsonNode.Parse(existing);
            if (root is JsonObject obj && obj.ContainsKey("statusLine"))
            {
                obj.Remove("statusLine");
                var options = new JsonSerializerOptions { WriteIndented = true };
                File.WriteAllText(SettingsPath, obj.ToJsonString(options));
            }
        }
        catch (Exception ex)
        {
            Logger.Log("Statusline: failed to clean settings.json - " + ex.Message);
        }
    }

    private static string GetScriptContent()
    {
        return @"# Claude Usage Statusline for Claude Code
# Generated by ClaudeUsageWin â€” do not edit manually

$historyPath = Join-Path $env:APPDATA 'ClaudeUsageWin\history.json'

try {
    if (-not (Test-Path $historyPath)) {
        Write-Output 'Claude: no data'
        exit
    }
    $history = Get-Content $historyPath -Raw | ConvertFrom-Json
    if ($history.Count -gt 0) {
        $latest = $history[-1]
        $pct = [int]$latest.FiveHourPct
        $bars = [math]::Round($pct / 10)
        $empty = 10 - $bars
        $bar = ([char]0x2593).ToString() * $bars + ([char]0x2591).ToString() * $empty

        # Compute approximate reset time (5h from last sample)
        $ts = [DateTime]::Parse($latest.Timestamp)
        $resetAt = $ts.AddHours(5)
        $resetStr = $resetAt.ToString('HH:mm')

        # ANSI colors: red >75%, yellow >50%, green otherwise
        $color = if ($pct -gt 75) { ""`e[31m"" } elseif ($pct -gt 50) { ""`e[33m"" } else { ""`e[32m"" }
        $reset = ""`e[0m""

        Write-Output ""${color}Usage: ${pct}% ${bar} `u{2192} Reset: ${resetStr}${reset}""
    } else {
        Write-Output 'Claude: no data'
    }
} catch {
    Write-Output 'Claude: --'
}
";
    }
}
